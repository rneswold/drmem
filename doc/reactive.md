**NOTE: This is a document from the earliest days of the project. It's
contents are mostly out-of-date but it contains a few items that are
still of interest. Once all of it has been obsoleted or rolled into
the actual documentation, this file will get deleted.**

# Reactive Engine

The Reactive Engine adds higher-level controls to the system. The
drivers in `drmem` interact with hardware and make them available as
"devices". These devices can be controlled through applications using
a GraphQL/gRPC interface. But in many cases, you want intelligent
control of the hardware without having an application running all the
time.

The Reactive Engine accepts a source file that describes the logic to
be run all the time in the context of the `drmem` process.

## Features

- When `drmem` starts, a command line or config file option
  specifies the source for the RE.
- The running system should allow a new source file to replace the
  current config. This prevents us from having to restart `drmem`
  everytime an edit is made.

# Grammar

The source file is decoded as utf-8 text.

## Types

This language will probably contain a large number of primitive types.
The language provides no way to create your own types; its use is to
tie together inputs and outputs using logic. The set of types will
represent the data used when reading or writing to hardware.

### Primitive Types

    bool                                true, false
    int         32-bit, signed          1, 1_000, -32_000_000
    float       64-bit, IEEE            1.0, 1.5e30
    string      utf-8 encoded           "can contain text"
    color       32-bit, unsigned        #ffffffff,
                                        #red,                  // named colors
                                        #(1.0, 1.0, 1.0)       // RGB
                                        #(1.0, 1.0, 1.0, 1.0)  // RGBA
                                        #(1.0, 1.0)            // XY
    stamp       64-bit, unsigned,
                milliseconds since
                1970, UTC

### Container Types

    (T1, T2, ..., Tn)   tuple with n values
    [T]                 array of T
    {T}                 stream of stamp/T pairs
                        when obtaining values from a stream, the
                        timestamp is guaranteed to always increase

## Functions

These are a handful of functions that come to mind.

    and : [{bool}] -> {bool}

      Returns a stream of bools which is the logical AND of the
      current values of the array of bool streams.


    blend : [color] -> color

      Blends an array of RGBA values. Colors at higher indexes have
      higher priority and overlay lower indexed colors. This function
      creates a priority scheme for multiple processes to control a
      single bulb. The only requirement is that higher priority sources
      need to set their alpha channel to 0.0 for lower priority sources
      to be seen.


    control : string -> {T} -> EFFECT

      Sends a stream of values to a device. The device must accept the
      data type, otherwise it's an error. "EFFECT" is just a notation
      indicating the function has side-effects.


    cycle : integer -> {bool} -> {bool}

      Generates a square wave with a period of milliseconds given by
      the first parameter. The output starts cycling when the second
      parameter changes from false to true and continues as long as it
      stays true. If the second parameter is the constant true, then
      the output will cycle forever.


    device : string -> {T}

      Creates a stream of values generated by the specified device.
      The stream emits another value when the associated driver writes
      a new value to the database.


    first : {T} -> (stamp, T)

      Returns the first value returned by the stream.


    hysteresis : T -> {T} -> {T} where T is float or integer

      Filters a stream by removing elements that haven't changed
      greater than the filter parameter.

        int     {int}   {int}
        2       0       0
        2       1       0
        2       2       2
        2       1       2
        2       3       2
        2       4       4
        2       1       1


    not : {bool} -> {bool}

      Returns a stream of bools which is the logical NOT of the input
      bool stream.


    or : [{bool}] -> {bool}

      Returns a stream of bools which is the logical OR of the
      current values of the array of bool streams.


    skip : integer -> {T} -> {T}

      'skip n s' returns a stream consisting of every nth item of the
      stream 's',


    switch : {bool} -> {T} -> {T} -> {T}

      Returns a stream consisting of the contents pulled from the two
      input streams. Which stream depends on the predicate stream's
      value. The timestamp for each generated value is the latest
      timestamp of the source stream and the predicate stream. For
      instance:

        {bool}  {int}   {int}   {result}
        true    1       10      1
                2               2
                        11      2
        false                   11
                        12      12
        true                    2


    timer : integer -> {bool} -> {bool}

        The first parameter is the number of milliseconds of the
        timer. The second is a stream of booleans. Anytime the stream
        delivers a false to true transition, the timer resets. The
        timer returns a stream of bools indicating when it changes
        state. true means it's counting down and false means it
        expired. If the second parameter is the constant true, this
        timer will fire once when starting the engine and never fire
        again.

## Expressions

If a stream is used in an expression, it's as though the expression is
a function -- much like the functional programming equivalent of a
`map` function (i.e. `map : (T1 -> T2) -> {T1} -> {T2}`.)

## Examples

### Example #1

For this example, assume a motion detector (`motion:status`) and a
light bulb (`bulb:status`). We want the change of the motion detector
state to control the bulb:

    control "bulb:status" (device "motion:status")

or (using a "pipe" operator):

    device "motion:status" |> control "bulb:status"

The intermediate values can be assigned to variables, if it makes the
code easier to read:

    let MOTION = device "motion:status"
    let BULB = control "bulb:status"

    MOTION |> BULB

### Example #2

Motion detectors turn off when the motion stops but we don't
necessarily want the light to go off. When motion is detected, we want
the lights to stay on for a minute -- even if the motion detector
stops sensing motion. In the previous example, the light would go out
once motion stopped.

In this example, we add a timer so the light turns on when motion is
detected and keeps the light on for a minute once motion stops.

    let MOTION = device "motion:status"
    let BULB = control "bulb:status"
    let TIMER = timer 60_000 (not MOTION)

    or [MOTION, TIMER] |> BULB

By OR-ing together the motion detector and the timer, you get the
following behavior:

             __           __   ______
    MOTION _|  |_________|  |_|      |__________
                _____        _____    _____
     TIMER ____|     |______|     |__|     |____
             ________     _________________
      BULB _|        |___|                 |____


Note that the `or-expression` and the timer are dependent on the
MOTION stream. If the `or-expression` is evaluated before the TIMER,
we could get a short low pulse going to the bulb. The Reactive Engine
must provide guarantees that expressions are evaluated in the correct
order so these race conditions aren't possible.

### Example #3

A sump pump driver provides these devices: `pump:state` and
`pump:duty`. The driver updates the duty cycle every time the state
transitions from on to off. The driver updates both parameters
atomically so they appear to update simultaneously (and they'll have
the same timestamp.)

When the pump is active, we turn on a color bulb, `bulb:color`, to
blue. If the duty cycle is over 20%, we turn the bulb yellow for 5
seconds after the pump turns off.

    let STATE = device "pump:state"
    let DUTY = device "pump:duty"

    // Define a 5 second timer that activates everytime the pump
    // turns off and the duty cycle is too high.

    let TIMER = timer 5_000 (and [not STATE, DUTY >= 20.0])

    // Create a stream that returns #yellow when the timer is active.
    // Otherwise it returns #black.

    let WARN = switch TIMER #yellow #black

    // Tie the logic together into a stream and send it to the bulb.

    switch STATE #blue WARN |> control "bulb:color"

## Implementation Details

This section is for brainstorming ideas on how some of these details
can be supported using `redis`.

### Synchronizing Data

As shown in some of the examples, the controlling logic can show
glitches if several devices updating simultaneously aren't handled
properly.

One of the first drivers I wrote, the sump pump monitor, guarantees
that three parameters are atomically updated and that they'll have the
same timestamps. Any use of these devices in the reactive engine
should assume the controlling logic will see them change
simultaneously.

To satisfy this requirement, these steps will be followed:

- When the Reactive Engine executes a new source file, all `device`
  streams are queried for their latest values using `XREVRANGE`. The
  results (timestamp and data) are saved in the state of each device.
- All EFFECT nodes are evaluated.
- All `device` streams are merged into a single, blocking `XREAD`
  command using timestamps from the previous iteration.
    - The results are sorted into ascending timestamp order.
    - For each unique timestamp:
        - the state of all devices associated with the timestamp are
          updated
        - all EFFECT nodes are evaluated

### Timers

The device streams are driving the engine but we also need to handle
timers. Before making the `XREAD` command, a timeout is calculated
from all the active timer streams. If the `XREAD` completes due to a
timeout, a blocking read is done on all the device streams to see if
there are any updates. The timer update is sorted with the device
events and handled as described in the previous section.

This event loop should keep track of the latest timestamp and write to
the log whenever new data arrives with an older timestamp.

This should mostly work when `redis` is running on the same node as
`drmem` (since they'll have the same system clock and, therefore,
correlated timestamps.) On distributed systems, timers may get
reported before remote data, so there may be out of order stamps.

*Do we need timestamps in the Reactive Engine?*

- Mostly no. The logic is tying together values from streams. Even
  timer streams generate `true`/`false` values so the logic doesn't
  need to see the timestamps.
- Yes. When we set the value of a writable device, it would be very
  useful for the timestamp to be that of the calculated value. So,
  even though it takes a small amount of time to re-evaluate the state
  changes, the database will show perfectly correlated data.
- Yes. We could create a function `delta : {_} -> {int}` that
  computes milliseconds between elements. If this function seems
  useful, then we need timestamps.

If we set a device and specify its stamp, it'll get stored in `redis`
with that timestamp. It's possible for a program to have a `control`
and `device` expression refer to the same device. If the stamp is, by
definition, the maximum of all the timestamps used to compute the
final value, then the `device` expression will return it during the
next loop of the event handler and its timestamp indicates it should
have been reported last loop.

I would have the Reactive Engine refuse to allow a device to be used
in both `device` and `control` expressions.

But then we have this: `bulb:state` is a Philips Hue bulb. We can
either read the state of the bulb or write state to it. But if someone
changes the state through the mobile app, we can only see the change
from a `device` expression. We'll be out of sync with the bulb if we
can only use `control`. Argh.

What does this do?

    let BULB_IN = device "bulb:state"
    let BULB_OUT = control "bulb:state"

    BULB_IN |> BULB_OUT

At first glance, it looks like an infinite loop: The state of the bulb
is obtained and fed back to the bulb, which update the state, which
immediately wakes up the engine and gets the state and sets the state,
...

But really this loop shouldn't be allowed to set the timestamp. The
Philips Hue interface is quick, but not millisecond quick. When a new
state is set, the driver will write it to the actual hardware and then
should write the real timestamp when it occurred.

So, although this example will loop, it is throttled by how quickly
the Hue Bridge can process the command.

So maybe we shouldn't have timestamps in the Reactive Engine. The
Engine will handle synchronized readings but can't provide correlated
settings. For instance, you can't use the Reactive Engine to update a
Celsius reading from a Fahrenheit reading using the same timestamp. To
have two related devices update at the same time (i.e. have the same
timestamp) it should be done in the driver and the driver should add
those entries atomically.
